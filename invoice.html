<!doctype html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><title>Invoice</title><link rel="stylesheet" href="styles.css"><style>
  .modal-backdrop { position:fixed !important; inset:0 !important; background:rgba(0,0,0,.5) !important; display:flex !important; align-items:center; justify-content:center; z-index:9999 !important; }
  .modal-backdrop.hidden { display:none !important; }
  .modal-card { background:var(--card,#fff); border-radius:12px; box-shadow:0 10px 30px rgba(0,0,0,.25); max-width:600px; width:92vw; position:relative; z-index:10000; }
  .modal-head { display:flex; align-items:center; justify-content:space-between; padding:14px 16px; border-bottom:1px solid var(--line,#e5e5e5); }
  .modal-head h3 { margin:0; font-size:1.25rem; }
  .btn-close { background:none; border:none; font-size:1.5rem; cursor:pointer; color:var(--muted); padding:0; }
  .modal-body { padding:16px; }
  .modal-foot { display:flex; justify-content:flex-end; gap:8px; padding:14px 16px; border-top:1px solid var(--line,#e5e5e5); }
</style></head><body>
<header class="top">
  <div class="container row top row">
    <a class="brand" href="dashboard.html" aria-label="Home">
      <img id="headerLogo" src="assets/XposeManagementCRMlogo.png" alt="Logo">
    </a>
    <nav>
      <a href="dashboard.html" class="">Dashboard</a>
      <a href="appointments.html" class="">Appointments</a>
      <a href="jobs.html" class="">Jobs</a>
      <a href="messages.html" class="">Messages</a>
      <a href="customers.html" class="">Customers</a>
      <a href="invoices.html" class="">Invoices</a>
      <a href="inventory.html" class="">Inventory</a>
      <a href="revenue.html" class="">Revenue</a>
      <a href="settings.html" class="">Settings</a>
      <a href="profile.html" class="">Profile</a>
    </nav>
    <div>
      <button id="themeToggle" class="btn" aria-label="Toggle theme">Theme</button>
      <button id="logoutBtn" class="btn" aria-label="Logout">Logout</button>
    </div>
  </div>
</header>
<main class="container" style="padding:16px 0"><div id="invBrand">
  <img id="invBrandLogo" src="assets/XposeManagementCRMlogo.png" alt="Logo" class="brand-left">
<div class="brand-right">
  <img alt="" id="brandShopLogo">
  <span id="brandShopName" style="font-weight: bold;"></span>
</div>
</div>
<!-- ...existing code... -->
<div class="no-print" style="text-align:right; margin-bottom:8px">
  <button class="btn" onclick="printInvoice()">Print</button>
  <button class="btn" id="exportPdfBtn" style="margin-left:8px">Export as PDF</button>
  <button class="btn primary" id="sendInvoiceBtn" style="margin-left:8px">üì§ Send to Customer</button>
</div>
<script src="vendor/jspdf.umd.min.js"></script>
<h1>Invoice <span id="invNo"></span></h1>
<div><b>Customer:</b> <span id="invCustomer">-</span></div><div><b>Vehicle:</b> <span id="invVehicle">-</span></div><p class="notice" id="invMeta" style="margin-top:6px"></p>
<div style="margin-top:16px; padding:12px; border:1px solid var(--line); border-radius:4px; background:var(--card);">
  <span id="invShopName"></span><br><span id="invShopAddress"></span><br><span id="invShopPhone"></span><br><span id="invShopEmail"></span>
</div>
<div style="margin-top:16px; padding:12px; border:1px solid var(--line); border-radius:4px; background:var(--card);">
  <table class="table" id="invItems"><thead><tr><th>Item</th><th>Qty</th><th>Price</th><th>Total</th></tr></thead><tbody id="invItemsBody"></tbody></table>
  <div style="text-align:right;margin-top:10px">
    <div><b>Subtotal:</b> <span id="iSub">0.00</span></div>
    <div><b>Tax:</b> <span id="iTax">0.00</span></div>
    <div><b>Discount:</b> <span id="iDisc">0.00</span></div>
    <div style="font-size:18px;margin-top:6px"><b>Grand Total:</b> <span id="iGrand">0.00</span></div>
  </div>
</div>
<img src="assets/logo.svg" alt="Xpose Management" id="printFooterLogo" class="no-screen">

<!-- Send Invoice Modal -->
<div id="sendInvoiceModal" class="modal-backdrop hidden no-print" onclick="closeSendInvoiceModal()">
  <div class="modal-card" onclick="event.stopPropagation()" style="max-width:480px">
    <div class="modal-head">
      <h3>üì§ Send Invoice</h3>
      <button onclick="closeSendInvoiceModal()" class="btn-close">&times;</button>
    </div>
    <div class="modal-body">
      <p style="margin-bottom:16px;color:var(--muted);">Send invoice #<span id="sendInvNumber"></span> to the customer:</p>
      
      <div style="margin-bottom:16px;">
        <label style="display:flex;align-items:center;gap:10px;cursor:pointer;padding:12px;background:var(--bg);border-radius:8px;border:1px solid var(--line);">
          <input type="checkbox" id="sendEmailCheckbox" checked style="width:20px;height:20px;">
          <div>
            <strong>üìß Email Invoice</strong>
            <div id="sendEmailAddress" style="font-size:0.875rem;color:var(--muted);"></div>
          </div>
        </label>
      </div>
      
      <div style="margin-bottom:16px;">
        <label style="display:flex;align-items:center;gap:10px;cursor:pointer;padding:12px;background:var(--bg);border-radius:8px;border:1px solid var(--line);">
          <input type="checkbox" id="sendSmsCheckbox" checked style="width:20px;height:20px;">
          <div>
            <strong>üì± Text Invoice</strong>
            <div id="sendSmsPhone" style="font-size:0.875rem;color:var(--muted);"></div>
          </div>
        </label>
      </div>

      <div id="sendInvoiceNoContact" style="display:none;padding:12px;background:#fef3c7;border-radius:8px;color:#92400e;margin-bottom:16px;">
        <strong>‚ö†Ô∏è No contact info found</strong>
        <p style="margin:8px 0 0;font-size:0.875rem;">Add customer email or phone to send invoice.</p>
      </div>

      <div id="sendInvoiceStatus" style="display:none;padding:12px;border-radius:8px;margin-bottom:16px;"></div>
    </div>
    <div class="modal-foot">
      <button id="sendInvSkip" class="btn" onclick="closeSendInvoiceModal()">Skip</button>
      <button id="sendInvBtn" class="btn primary">Send Invoice</button>
    </div>
  </div>
</div>

</main><footer class="container">¬© <span id="footerShopName"></span></footer><script src="vendor/supabase.umd.js"></script><script type="module" src="app.js"></script><script src="multi-tenant.js"></script>
<!-- Fallback global print handler (will be overridden by module) -->
<script>
  window.exportInvoiceAsPDF = async function() {
    // Use jsPDF to export the invoice area as PDF
    const { jsPDF } = window.jspdf || {};
    if (!jsPDF) { alert('PDF export library not loaded.'); return; }
    const doc = new jsPDF({ unit: 'pt', format: 'a4' });
    // Get invoice main content
    const invoiceEl = document.querySelector('main.container');
    if (!invoiceEl) { alert('Invoice content not found.'); return; }
    // Use html2canvas for better rendering if available
    if (window.html2canvas) {
      const canvas = await window.html2canvas(invoiceEl);
      const imgData = canvas.toDataURL('image/png');
      doc.addImage(imgData, 'PNG', 20, 20, 555, 780, undefined, 'FAST');
    } else {
      doc.text(invoiceEl.innerText, 20, 40);
    }
    doc.save('invoice.pdf');
  };
  document.addEventListener('DOMContentLoaded', function() {
    const btn = document.getElementById('exportPdfBtn');
    if (btn) btn.onclick = window.exportInvoiceAsPDF;
  });
  window.printInvoice = function(){ window.print(); };
</script>
<script>
/* ============ CRM-Xpose: Per-Part Labor (Step 1 / Data + Modal API) ============ */
(function () {
  const STORAGE_PREFIX = 'crm:savedLaborRates:';

  function getShopId() {
    try {
      const session = JSON.parse(localStorage.getItem('crm:session') || '{}');
      return session?.activeShopId || session?.shopId || 'default';
    } catch (e) {
      return 'default';
    }
  }

  function loadRates() {
    try {
      const key = STORAGE_PREFIX + getShopId();
      return JSON.parse(localStorage.getItem(key) || '[]');
    } catch {
      return [];
    }
  }

  function saveRates(rates) {
    const key = STORAGE_PREFIX + getShopId();
    localStorage.setItem(key, JSON.stringify(rates));
  }

  function addRate(label, value) {
    const v = Number(value);
    if (!label || !Number.isFinite(v)) return { ok: false, error: 'Invalid name or rate' };
    const rates = loadRates();
    const idx = rates.findIndex(r => r.label === label);
    const item = { label, value: v };
    if (idx >= 0) rates[idx] = item;
    else rates.push(item);
    saveRates(rates);
    return { ok: true, rates };
  }

  function removeRate(label) {
    const rates = loadRates().filter(r => r.label !== label);
    saveRates(rates);
    return rates;
  }

  function renderIntoModal() {
    const modal = document.getElementById('laborModal');
    if (!modal) return;
    const sel = modal.querySelector('[data-el="rateSelect"]');
    if (!sel) return;
    const rates = loadRates();
    sel.innerHTML =
      '<option value="">Custom rate‚Ä¶</option>' +
      rates.map(r => `<option value="${r.value}">${r.label} ‚Äî $${Number(r.value).toFixed(2)}/hr</option>`).join('');
  }

  function setupModalHandlers() {
    const modal = document.getElementById('laborModal');
    if (!modal) return;

    const sel = modal.querySelector('[data-el="rateSelect"]');
    const customRate = modal.querySelector('[data-el="rateInput"]');
    const hoursInput = modal.querySelector('[data-el="hoursInput"]');
    const addBtn = modal.querySelector('[data-el="addRateBtn"]');
    const saveBtn = modal.querySelector('[data-el="saveRateBtn"]');
    const nameInput = modal.querySelector('[data-el="rateNameInput"]');
    const valueInput = modal.querySelector('[data-el="rateValueInput"]');
    const addPanel = modal.querySelector('[data-el="addRatePanel"]');
    const closeButtons = modal.querySelectorAll('[data-action="closeLaborModal"]');

    sel && sel.addEventListener('change', () => {
      if (sel.value) customRate.value = sel.value;
    });

    addBtn && addBtn.addEventListener('click', () => {
      addPanel && addPanel.classList.remove('hidden');
      nameInput && nameInput.focus();
    });

    saveBtn && saveBtn.addEventListener('click', () => {
      const name = (nameInput?.value || '').trim();
      const val = parseFloat(valueInput?.value);
      const res = addRate(name, val);
      if (!res.ok) { alert('Enter a valid name and numeric hourly rate.'); return; }
      if (nameInput) nameInput.value = '';
      if (valueInput) valueInput.value = '';
      addPanel && addPanel.classList.add('hidden');
      renderIntoModal();
    });

    closeButtons.forEach(btn => btn.addEventListener('click', () => modal.classList.add('hidden')));

    renderIntoModal();
  }

  // Promise-based opener; will be used in Step 2 when we wire it in.
  function openLaborModal(initialRate, initialHours) {
    const modal = document.getElementById('laborModal');
    if (!modal) return Promise.resolve(null);

    modal.classList.remove('hidden');
    renderIntoModal();
    setupModalHandlers();

    const rateInput = modal.querySelector('[data-el="rateInput"]');
    const hoursInput = modal.querySelector('[data-el="hoursInput"]');
    if (rateInput) rateInput.value = (initialRate ?? '');
    if (hoursInput) hoursInput.value = (initialHours ?? 1);

    return new Promise(resolve => {
      const cancel = modal.querySelector('[data-action="closeLaborModal"]');
      const confirm = modal.querySelector('[data-action="confirmLabor"]');

      const onCancel = () => { cleanup(); resolve(null); };
      const onConfirm = () => {
        const rate = parseFloat(rateInput?.value);
        const hours = parseFloat(hoursInput?.value);
        if (!Number.isFinite(rate) || !Number.isFinite(hours) || hours <= 0) {
          alert('Enter valid numbers for hours and rate.');
          return;
        }
        cleanup();
        resolve({ hours, rate, total: rate * hours });
      };

      function cleanup() {
        confirm && confirm.removeEventListener('click', onConfirm);
        cancel && cancel.removeEventListener('click', onCancel);
        modal.classList.add('hidden');
      }

      confirm && confirm.addEventListener('click', onConfirm);
      cancel && cancel.addEventListener('click', onCancel);
    });
  }

  // Expose a tiny API for later steps.
  window.LaborRates = {
    load: loadRates,
    add: addRate,
    remove: removeRate,
    openLaborModal,
    renderIntoModal
  };
})();
</script>

<script type="module">
import { getSupabaseClient } from './helpers/supabase.js';
import { getShopData } from './helpers/storage.js';

(async function(){
  try{
    const q = new URLSearchParams(location.search);
    const id = q.get('id');
    if (!id) return;

    // Always try to fetch the latest invoice from Supabase first
    const supabase = await getSupabaseClient();
    let inv = null;
    let data = JSON.parse(localStorage.getItem('xm_data') || '{}') || {};
    let supabaseInvoice = null;
    if (supabase) {
      try {
        const { data: rows, error } = await supabase.from('invoices').select('*').or(`id.eq.${id},number.eq.${id}`).limit(1);
        if (!error && rows && rows.length) {
          supabaseInvoice = rows[0];
        }
      } catch (e) { /* ignore */ }
    }
    if (supabaseInvoice) {
      inv = supabaseInvoice;
    } else {
      // Fallback to local cache
      inv = (data.invoices || []).find(i => String(i.id) === id || String(i.number) === id);
    }

    // Helper to render invoice object into DOM
    function renderInvoice(invObj, allData, shopSource) {
      if (!invObj) return;
      const invNoEl = document.getElementById('invNo');
      const invCustomerEl = document.getElementById('invCustomer');
      const invVehicleEl = document.getElementById('invVehicle');
      const metaEl = document.getElementById('invMeta');
      const shopNameEl = document.getElementById('invShopName');
      const shopPhoneEl = document.getElementById('invShopPhone');
      const shopEmailEl = document.getElementById('invShopEmail');
      const itemsTbody = document.querySelector('#invItems tbody');
      const subEl = document.getElementById('iSub');
      const taxEl = document.getElementById('iTax');
      const discEl = document.getElementById('iDisc');
      const grandEl = document.getElementById('iGrand');

      console.debug('[Invoice] renderInvoice called', { id: invObj && invObj.id, number: invObj && invObj.number, shopSource });
      invNoEl.textContent = invObj.number || invObj.id || 'N/A';
      // FIX: Always prefer customer_first/customer_last over customer (which is a UUID)
      invCustomerEl.textContent = (invObj.customer_first || invObj.customer_last) ? 
        ((invObj.customer_first || '') + ' ' + (invObj.customer_last || '')).trim() : 
        (invObj.customer || '');
      // Vehicle: always prefer invoice.vehicle, fallback to job/appointment if missing
      let vehicle = invObj.vehicle || '';
      if (!vehicle && invObj.job_id && allData && Array.isArray(allData.jobs)) {
        const job = allData.jobs.find(j => j.id === invObj.job_id || j.appointment_id === invObj.appointment_id);
        if (job && job.vehicle) vehicle = job.vehicle;
      }
      if (!vehicle && invObj.appointment_id && allData && Array.isArray(allData.appointments)) {
        const appt = allData.appointments.find(a => a.id === invObj.appointment_id);
        if (appt && appt.vehicle) vehicle = appt.vehicle;
      }
      // PATCH: If invoice.vehicle is present, always show it
      invVehicleEl.textContent = invObj.vehicle || vehicle || '';

  // Shop info: prefer allData.settings.shop, fall back to xm_shops.
      // Treat seeded/demo shop names as non-authoritative so they don't show in production UI.
      const DEFAULT_SHOP_NAME = 'Xpose Management';
      const demoNames = ['GR Automotive'];
  const shopInfo = (allData && allData.settings && allData.settings.shop) || JSON.parse(localStorage.getItem('xm_shops') || 'null') || null;
      let s = null;
      if (shopInfo) s = Array.isArray(shopInfo) ? shopInfo[0] : shopInfo;

      // Clean, labelled display for shop "From" block
      let displayName = DEFAULT_SHOP_NAME;
      let displayPhone = '';
      let displayEmail = '';
      if (s && typeof s.name === 'string' && s.name.trim() && !demoNames.includes(s.name.trim())) {
        displayName = s.name || DEFAULT_SHOP_NAME;
        displayPhone = s.phone || '';
        displayEmail = s.email || '';
        // If no explicit source was passed, assume it came from data.settings
        shopSource = shopSource || (allData && allData.settings && allData.settings.shop ? 'data.settings' : 'xm_shops');
      } else {
        // No authoritative shop data found ‚Äî use a friendly default rather than seeded demo text.
        displayName = DEFAULT_SHOP_NAME;
        displayPhone = '';
        displayEmail = '';
        shopSource = shopSource || 'default_fallback';
      }

  // Render labels in bold, escape values to avoid HTML injection
  function esc(v){ return String(v || '').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;').replace(/'/g,'&#39;'); }
  shopNameEl.innerHTML = `<strong>Name:</strong> ${esc(displayName)}`;
  // Compose full address line (support many possible field names)
  const shopAddressEl = document.getElementById('invShopAddress');
  let addressParts = [];
  const streetFields = ['street','address','address1','address_line1','address_line_1','street1','line1'];
  const cityFields = ['city','town','locality'];
  const stateFields = ['state','region','province'];
  const zipFields = ['zipcode','zip','postal_code','postal'];

  function pushFirstExisting(obj, fields) {
    for (const f of fields) {
      if (obj && typeof obj[f] === 'string' && obj[f].trim()) { addressParts.push(obj[f].trim()); return; }
    }
  }

  pushFirstExisting(s, streetFields);
  pushFirstExisting(s, cityFields);
  pushFirstExisting(s, stateFields);
  pushFirstExisting(s, zipFields);

  // Fallback to single-line address fields if present
  if (!addressParts.length && s) {
    const fallbackAddr = s.address || s.full_address || s.location || s.address_line || s.addr;
    if (fallbackAddr && typeof fallbackAddr === 'string' && fallbackAddr.trim()) addressParts.push(fallbackAddr.trim());
  }

  if (shopAddressEl) {
    shopAddressEl.innerHTML = `<strong>Address:</strong> ${esc(addressParts.join(', ') || 'N/A')}`;
  } else {
    console.warn('[Invoice] invShopAddress element not found');
  }
  shopPhoneEl.innerHTML = `<strong>Number:</strong> ${esc(displayPhone)}`;
  shopEmailEl.innerHTML = `<strong>Email:</strong> ${esc(displayEmail)}`;

  // Show shop logo in header (top-right) and on the invoice brand area (top of invoice)
  try {
    const logoSrc = (s && (s.logo || s.logo_url || s.image)) ? (s.logo || s.logo_url || s.image) : '';
    const brandLogoEl = document.getElementById('brandShopLogo');
    const brandNameEl = document.getElementById('brandShopName');
    if (logoSrc) {
      if (brandLogoEl) { brandLogoEl.src = logoSrc; brandLogoEl.style.display = 'inline-block'; brandLogoEl.style.height = '48px'; brandLogoEl.style.width = 'auto'; brandLogoEl.style.marginRight = '8px'; }
    } else {
      if (brandLogoEl) { brandLogoEl.src = ''; brandLogoEl.style.display = 'none'; }
    }
    if (brandNameEl) brandNameEl.textContent = displayName || '';
  } catch (e) {}

  // If shop info is missing or incomplete, try fetching authoritative shop row from Supabase
  (async function tryFetchShop() {
    try {
      const needsFetch = !s || !s.name || !s.street && !s.address && !s.full_address;
      const shopIdCandidate = (invObj && invObj.shop_id) || (allData && allData.settings && allData.settings.shop && (Array.isArray(allData.settings.shop) ? allData.settings.shop[0] && (allData.settings.shop[0].id || allData.settings.shop[0].shop_id) : (allData.settings.shop.id || allData.settings.shop.shop_id))) || null;
      if (needsFetch && shopIdCandidate && typeof getSupabaseClient === 'function') {
        const supabase = await getSupabaseClient();
        if (supabase) {
          const { data: shopRow, error: shopErr } = await supabase.from('shops').select('*').eq('id', shopIdCandidate).single();
          if (!shopErr && shopRow) {
            s = shopRow;
            // Recompute display values
            displayName = s.name || displayName;
            displayPhone = s.phone || displayPhone;
            displayEmail = s.email || displayEmail;
            shopNameEl.innerHTML = `<strong>Name:</strong> ${esc(displayName)}`;

            // recompute addressParts (use same helpers/fields as above)
            let newAddressParts = [];
            const streetFields = ['street','address','address1','address_line1','address_line_1','street1','line1'];
            const cityFields = ['city','town','locality'];
            const stateFields = ['state','region','province'];
            const zipFields = ['zipcode','zip','postal_code','postal'];
            function pushFirstExisting(obj, fields) { for (const f of fields) { if (obj && typeof obj[f] === 'string' && obj[f].trim()) { newAddressParts.push(obj[f].trim()); return; } } }
            pushFirstExisting(s, streetFields); pushFirstExisting(s, cityFields); pushFirstExisting(s, stateFields); pushFirstExisting(s, zipFields);
            if (!newAddressParts.length) {
              const fallbackAddr = s.address || s.full_address || s.location || s.address_line || s.addr;
              if (fallbackAddr && typeof fallbackAddr === 'string' && fallbackAddr.trim()) newAddressParts.push(fallbackAddr.trim());
            }
            if (shopAddressEl) shopAddressEl.innerHTML = `<strong>Address:</strong> ${esc(newAddressParts.join(', ') || 'N/A')}`;
            if (shopPhoneEl) shopPhoneEl.innerHTML = `<strong>Number:</strong> ${esc(displayPhone)}`;
            if (shopEmailEl) shopEmailEl.innerHTML = `<strong>Email:</strong> ${esc(displayEmail)}`;

            // update brand area logo/name if available
            try {
              const brandLogoEl2 = document.getElementById('brandShopLogo');
              const brandNameEl2 = document.getElementById('brandShopName');
              const logoSrc2 = (s && (s.logo || s.logo_url || s.image)) ? (s.logo || s.logo_url || s.image) : '';
              if (logoSrc2 && brandLogoEl2) { brandLogoEl2.src = logoSrc2; brandLogoEl2.style.display = 'inline-block'; }
              if (brandNameEl2) brandNameEl2.textContent = displayName || '';
            } catch (e) {}
          }
        }
      }
    } catch (e) { console.warn('[Invoice] tryFetchShop failed', e); }
  })();

    // Set print footer logo to shop logo when available (falls back to platform logo)
    try {
      const printLogo = document.getElementById('printFooterLogo');
      if (printLogo) {
        // Always use the platform/header logo for printed footer (platform branding)
        const headerLogoEl = document.getElementById('headerLogo');
        const footerLogoSrc = (headerLogoEl && headerLogoEl.src) ? headerLogoEl.src : 'assets/logo.svg';
        printLogo.src = footerLogoSrc;
        // Ensure the print logo resource is loaded by creating a hidden loader image
        try {
          let loader = document.getElementById('printFooterLogoLoader');
          if (!loader) {
            loader = document.createElement('img');
            loader.id = 'printFooterLogoLoader';
            loader.style.width = '0';
            loader.style.height = '0';
            loader.style.position = 'absolute';
            loader.style.left = '-9999px';
            loader.style.top = 'auto';
            document.body.appendChild(loader);
          }
          loader.src = footerLogoSrc;
        } catch (e) {}
      }
    } catch (e) {}

      // Update debug banner if present
      // ...existing code...

      // Meta: status, due, paid_date
      const parts = [];
      if (invObj.status) parts.push(invObj.status.toUpperCase());
      if (invObj.due) parts.push('Due: ' + invObj.due);
      if (invObj.paid_date) parts.push('Paid: ' + (new Date(invObj.paid_date).toLocaleDateString()));
      if (Array.isArray(invObj.job_numbers) && invObj.job_numbers.length) parts.push('Jobs: ' + invObj.job_numbers.join(', '));
      if (Array.isArray(invObj.job_ids) && invObj.job_ids.length && allData && Array.isArray(allData.jobs)) {
        const jobs = (allData.jobs || []).filter(j => invObj.job_ids.includes(j.id)).map(j => j.number || j.id);
        if (jobs.length) parts.push('Jobs: ' + jobs.join(', '));
      }
      metaEl.textContent = parts.join(' ¬∑ ');

      // Items

      itemsTbody.innerHTML = '';
      const items = invObj.items || [];
      let subtotal = 0;

      // Group items by type
      const partItems = [];
      const laborItems = [];
      const serviceItems = [];
      const partLaborGroups = [];
      const servicePartGroups = [];
      const serviceLaborGroups = [];
      let usedIndexes = new Set();

      // 1. Load service names from settings for strict matching
      let serviceNames = [];
      try {
        const d = JSON.parse(localStorage.getItem('xm_data') || '{}');
        serviceNames = ((d.settings && d.settings.services) || []).map(s => (s.name || '').toLowerCase().trim());
      } catch (e) { serviceNames = []; }

      // 2. First pass: Detect explicit linked pairs (Part+Labor, Service+Part, Service+Labor)
      // Look for items with linkedItemId to identify explicit pairs
      for (let i = 0; i < items.length; i++) {
        if (usedIndexes.has(i)) continue;
        const itm = items[i];
        
        // Check if this item has a linkedItemId (indicates it's part of a pair)
        if (itm.linkedItemId) {
          // Find the linked item
          const linkedIdx = items.findIndex((item, idx) => 
            item.id === itm.linkedItemId && !usedIndexes.has(idx)
          );
          
          if (linkedIdx !== -1) {
            const linkedItem = items[linkedIdx];
            // If either item matches a known service name, treat as a service-group
            const itmName = (itm.name || '').toLowerCase().trim();
            const linkedName = (linkedItem.name || '').toLowerCase().trim();
            const itmIsService = (serviceNames.length && serviceNames.includes(itmName)) || itm.type === 'service' || itm.pricing_type === 'labor_based' || itm.pricingType === 'labor_based' || itm.isService === true;
            const linkedIsService = (serviceNames.length && serviceNames.includes(linkedName)) || linkedItem.type === 'service' || linkedItem.pricing_type === 'labor_based' || linkedItem.pricingType === 'labor_based' || linkedItem.isService === true;

            if (itmIsService || linkedIsService) {
              // Identify service and partner (part or labor)
              const service = itmIsService ? itm : linkedItem;
              const other = itmIsService ? linkedItem : itm;
              const otherIsPart = (other.type === 'part') || (other.part_number) || (typeof other.cost_price !== 'undefined') || (other.name||'').toLowerCase().startsWith('part:');
              if (otherIsPart) servicePartGroups.push([service, other]);
              else serviceLaborGroups.push([service, other]);
              usedIndexes.add(i);
              usedIndexes.add(linkedIdx);
              continue;
            }

            // Determine which is part and which is labor by type property first, then name
            const isPart = (itm.type === 'part') || 
                          (itm.name || '').toLowerCase().startsWith('part:') || 
                          itm.part_number || 
                          typeof itm.cost_price !== 'undefined';
            
            if (isPart) {
              partLaborGroups.push([itm, linkedItem]);
            } else {
              partLaborGroups.push([linkedItem, itm]);
            }
            usedIndexes.add(i);
            usedIndexes.add(linkedIdx);
            continue;
          }
        }
        
        // ALSO check reverse: if this item has an 'id', look for any labor items that link TO it
        // This handles cases where the service is processed before its linked labor
        if (itm.id && (itm.type === 'service' || itm.pricing_type === 'labor_based')) {
          const linkedLaborIdx = items.findIndex((item, idx) => 
            item.linkedItemId === itm.id && !usedIndexes.has(idx) && item.type === 'labor'
          );
          
          if (linkedLaborIdx !== -1) {
            const laborItem = items[linkedLaborIdx];
            serviceLaborGroups.push([itm, laborItem]);
            usedIndexes.add(i);
            usedIndexes.add(linkedLaborIdx);
            continue;
          }
        }
        
        // Fallback: Check for sequential Service+Labor ONLY if the service has price=0 (labor-based service)
        // This prevents flat-rate services from being incorrectly grouped with unrelated labor items
        const nameLower = (itm.name || '').toLowerCase().trim();
        const isServiceItem = (serviceNames.length && serviceNames.includes(nameLower)) || itm.type === 'service' || itm.pricing_type === 'labor_based' || itm.pricingType === 'labor_based' || itm.isService === true;
        const isLaborBasedService = isServiceItem && (Number(itm.price) === 0 || itm.pricingType === 'labor' || itm.pricing_type === 'labor_based' || itm.isLaborBased === true);

        if (isLaborBasedService) {
          for (let j = i + 1; j < items.length && j <= i + 2; j++) {
            if (usedIndexes.has(j)) continue;
            const nextItem = items[j];
            const nextName = (nextItem.name || '').toLowerCase().trim();
            const nextIsLabor = (nextItem.type === 'labor') || nextName.startsWith('labor') || nextName.includes('labor');
            if (nextIsLabor) { serviceLaborGroups.push([itm, nextItem]); usedIndexes.add(i); usedIndexes.add(j); break; }
          }
          if (usedIndexes.has(i)) continue;
        }

        // Fallback: Check for sequential Part+Labor by type or naming convention
        // NOTE: We do NOT auto-pair flat-rate services with labor here
        // This prevents flat-rate services from being incorrectly grouped with unrelated labor items
        const isPartByType = (itm.type === 'part');
        const isPartByName = (itm.name || '').toLowerCase().trim().startsWith('part:');
        
        if (isPartByType || isPartByName) {
          // Look ahead for matching labor item
          for (let j = i + 1; j < items.length && j <= i + 2; j++) {
            if (usedIndexes.has(j)) continue;
            const nextItem = items[j];
            const nextName = (nextItem.name || '').toLowerCase().trim();
            
            // Check if next item is labor by type first, then by naming patterns
            const isLaborByType = (nextItem.type === 'labor');
            const isLaborByName = nextName.startsWith('labor') || nextName.startsWith('labor:') || 
                nextName.includes('labor for') || nextName.includes('installation');
            
            if (isLaborByType || isLaborByName) {
              partLaborGroups.push([itm, nextItem]);
              usedIndexes.add(i);
              usedIndexes.add(j);
              break;
            }
          }
        }
      }

      // 3. Second pass: Classify remaining items
      for (let i = 0; i < items.length; i++) {
        if (usedIndexes.has(i)) continue;
        const itm = items[i];
        const name = (itm.name || '').toLowerCase().trim();

        // Priority 1: Service (strict - must match settings)
        if ((serviceNames.length && serviceNames.includes(name)) || itm.type === 'service' || itm.pricing_type === 'labor_based' || itm.pricingType === 'labor_based' || itm.isService === true) {
          serviceItems.push(itm);
          continue;
        }

        // Priority 2: Labor (by naming patterns and known labor types)
        const isLabor = 
          name.startsWith('labor') || 
          name.startsWith('labor:') || 
          name.startsWith('labor -') ||
          name.includes(' labor') ||
          name === 'standard' || 
          name === 'diagnostic' || 
          name === 'inspection' || 
          name === 'friends & family' ||
          name.includes('hourly rate') ||
          name.includes('/hr') ||
          name.includes('hours');

        if (isLabor) {
          laborItems.push(itm);
          continue;
        }

        // Priority 3: Part (by naming, properties, or default)
        const isPart = 
          name.startsWith('part:') || 
          name.startsWith('part -') ||
          name.includes('part #') ||
          itm.part_number || 
          typeof itm.cost_price !== 'undefined' || 
          typeof itm.cost !== 'undefined';

        if (isPart) {
          partItems.push(itm);
          continue;
        }

        // Default: Categorize by price/qty heuristics
        // If it looks like a labor charge (hours-based), classify as labor
        if ((itm.qty > 0 && itm.qty <= 24) && itm.price >= 50 && itm.price <= 500) {
          laborItems.push(itm);
        } else {
          // Default to part
          partItems.push(itm);
        }
      }

      // Render Part+Labor groups
      if (partLaborGroups.length) {
        for (const [part, labor] of partLaborGroups) {
          // Use groupName for the group title if present (check both part and labor), else default to part name + ' P+R'
          let groupTitle = (part.groupName && part.groupName.trim()) || (labor.groupName && labor.groupName.trim()) || (part.name.replace(/^part:/i, '').trim() + ' P+R');
          // Group header
          const trHeader = document.createElement('tr');
          trHeader.innerHTML = `<td colspan="4" style="font-weight:bold;background:var(--line);color:var(--text);padding:8px;">${groupTitle}</td>`;
          itemsTbody.appendChild(trHeader);
          // Part row (always show part name)
          let partQty = Number(part.qty) || 0;
          let partPrice = Number(part.price) || 0;
          let partTotal = partQty * partPrice;
          subtotal += partTotal;
          let displayPartName = part.name.replace(/^part:/i, '').trim() || 'Part';
          const trPart = document.createElement('tr');
          trPart.innerHTML = `<td style="padding-left:20px;">${displayPartName}</td><td style="text-align:center">${partQty}</td><td style="text-align:right">${partPrice.toFixed(2)}</td><td style="text-align:right">${partTotal.toFixed(2)}</td>`;
          itemsTbody.appendChild(trPart);
          
          // Labor row
          let laborQty = Number(labor.qty) || 0;
          let laborPrice = Number(labor.price) || 0;
          let laborTotal = laborQty * laborPrice;
          subtotal += laborTotal;
          // Extract actual labor description
          let displayLaborName = labor.name.replace(/^labor:/i, '').trim() || `Labor (${laborQty} hr${laborQty !== 1 ? 's' : ''})`;
          displayLaborName = `Labor - ${displayLaborName}`;
          const trLabor = document.createElement('tr');
          trLabor.innerHTML = `<td style="padding-left:20px;">${displayLaborName}</td><td style="text-align:center">${laborQty}</td><td style="text-align:right">${laborPrice.toFixed(2)}</td><td style="text-align:right">${laborTotal.toFixed(2)}</td>`;
          itemsTbody.appendChild(trLabor);
          
          // Subtotal row for this group
          const groupSubtotal = partTotal + laborTotal;
          const trSubtotal = document.createElement('tr');
          trSubtotal.innerHTML = `<td colspan="3" style="text-align:right;padding-right:10px;font-weight:500;font-style:italic;">Subtotal</td><td style="text-align:right;font-weight:500;">${groupSubtotal.toFixed(2)}</td>`;
          itemsTbody.appendChild(trSubtotal);
          
          // Spacer row
          const trSpacer = document.createElement('tr');
          trSpacer.innerHTML = `<td colspan="4" style="height:8px;"></td>`;
          itemsTbody.appendChild(trSpacer);
        }
      }
      // Render Service+Part groups
      if (servicePartGroups.length) {
        for (const [service, part] of servicePartGroups) {
          let groupTitle = (service.groupName && service.groupName.trim()) || (service.name && service.name.trim()) || 'Service + Part';
          const trHeader = document.createElement('tr');
          trHeader.innerHTML = `<td colspan="4" style="font-weight:bold;background:var(--line);color:var(--text);padding:8px;">${groupTitle}</td>`;
          itemsTbody.appendChild(trHeader);

          // Service row
          const svcQty = Number(service.qty) || 0;
          const svcPrice = Number(service.price) || 0;
          const svcTotal = svcQty * svcPrice;
          subtotal += svcTotal;
          const trSvc = document.createElement('tr');
          trSvc.innerHTML = `<td style="padding-left:20px;">${service.name}</td><td style="text-align:center">${svcQty}</td><td style="text-align:right">${svcPrice.toFixed(2)}</td><td style="text-align:right">${svcTotal.toFixed(2)}</td>`;
          itemsTbody.appendChild(trSvc);

          // Part row
          const partQty = Number(part.qty) || 0;
          const partPrice = Number(part.price) || 0;
          const partTotal = partQty * partPrice;
          subtotal += partTotal;
          const trPart = document.createElement('tr');
          trPart.innerHTML = `<td style="padding-left:20px;">${(part.name || '').replace(/^part:/i,'').trim() || 'Part'}</td><td style="text-align:center">${partQty}</td><td style="text-align:right">${partPrice.toFixed(2)}</td><td style="text-align:right">${partTotal.toFixed(2)}</td>`;
          itemsTbody.appendChild(trPart);

          // Group subtotal
          const groupSubtotal = svcTotal + partTotal;
          const trSubtotal = document.createElement('tr');
          trSubtotal.innerHTML = `<td colspan="3" style="text-align:right;padding-right:10px;font-weight:500;font-style:italic;">Subtotal</td><td style="text-align:right;font-weight:500;">${groupSubtotal.toFixed(2)}</td>`;
          itemsTbody.appendChild(trSubtotal);

          const trSpacer = document.createElement('tr');
          trSpacer.innerHTML = `<td colspan="4" style="height:8px;"></td>`;
          itemsTbody.appendChild(trSpacer);
        }
      }
      // Render Service+Labor groups (each service with its labor in own section)
      if (serviceLaborGroups.length) {
        for (const [service, labor] of serviceLaborGroups) {
          let groupTitle = (service.groupName && service.groupName.trim()) || (service.name && service.name.trim()) || 'Service + Labor';
          const trHeader = document.createElement('tr');
          trHeader.innerHTML = `<td colspan="4" style="font-weight:bold;background:var(--line);color:var(--text);padding:8px;">${groupTitle}</td>`;
          itemsTbody.appendChild(trHeader);

          // Service row - show empty price/total (price is on labor row)
          const trSvc = document.createElement('tr');
          trSvc.innerHTML = `<td style="padding-left:20px;">${service.name}</td><td style="text-align:center"></td><td style="text-align:right"></td><td style="text-align:right"></td>`;
          itemsTbody.appendChild(trSvc);

          // Labor row - this is where the price shows
          const laborQty = Number(labor.qty) || 0;
          const laborPrice = Number(labor.price) || 0;
          const laborTotal = laborQty * laborPrice;
          subtotal += laborTotal;
          let displayLaborName = labor.name ? `Labor - ${labor.name}` : `Labor (${laborQty} hr${laborQty !== 1 ? 's' : ''})`;
          const trLabor = document.createElement('tr');
          trLabor.innerHTML = `<td style="padding-left:20px;">${displayLaborName}</td><td style="text-align:center">${laborQty}</td><td style="text-align:right">${laborPrice.toFixed(2)}</td><td style="text-align:right">${laborTotal.toFixed(2)}</td>`;
          itemsTbody.appendChild(trLabor);

          // Group subtotal (only labor total since service has no separate price)
          const groupSubtotal = laborTotal;
          const trSubtotal = document.createElement('tr');
          trSubtotal.innerHTML = `<td colspan="3" style="text-align:right;padding-right:10px;font-weight:500;font-style:italic;">Subtotal</td><td style="text-align:right;font-weight:500;">${groupSubtotal.toFixed(2)}</td>`;
          itemsTbody.appendChild(trSubtotal);

          const trSpacer = document.createElement('tr');
          trSpacer.innerHTML = `<td colspan="4" style="height:8px;"></td>`;
          itemsTbody.appendChild(trSpacer);
        }
      }
      // Render Parts
      if (partItems.length) {
          const tr = document.createElement('tr');
        tr.innerHTML = `<td colspan="4" style="font-weight:bold;background:var(--line);color:var(--text);padding:8px;">Parts</td>`;
        itemsTbody.appendChild(tr);
        for (const itm of partItems) {
          const qty = Number(itm.qty) || 0;
          const price = Number(itm.price) || 0;
          const total = qty * price;
          subtotal += total;
          const trPart = document.createElement('tr');
          trPart.innerHTML = `<td>${itm.name}</td><td style="text-align:center">${qty}</td><td style="text-align:right">$${price.toFixed(2)}</td><td style="text-align:right">$${total.toFixed(2)}</td>`;
          itemsTbody.appendChild(trPart);
        }
      }
      // Render Labor
      if (laborItems.length) {
        const tr = document.createElement('tr');
        tr.innerHTML = `<td colspan="4" style="font-weight:bold;background:var(--line);color:var(--text);padding:8px;">Labor</td>`;
        itemsTbody.appendChild(tr);
        for (const itm of laborItems) {
          const qty = Number(itm.qty) || 0;
          const price = Number(itm.price) || 0;
          const total = qty * price;
          subtotal += total;
          const trLabor = document.createElement('tr');
          let displayLaborName = itm.name ? `Labor - ${itm.name}` : 'Labor';
          trLabor.innerHTML = `<td>${displayLaborName}</td><td style="text-align:center">${qty}</td><td style="text-align:right">$${price.toFixed(2)}</td><td style="text-align:right">$${total.toFixed(2)}</td>`;
          itemsTbody.appendChild(trLabor);
        }
      }
      // Render Services
      if (serviceItems.length) {
        const tr = document.createElement('tr');
        tr.innerHTML = `<td colspan="4" style="font-weight:bold;background:var(--line);color:var(--text);padding:8px;">Services</td>`;
        itemsTbody.appendChild(tr);
        for (const itm of serviceItems) {
          const qty = Number(itm.qty) || 0;
          const price = Number(itm.price) || 0;
          const total = qty * price;
          subtotal += total;
          const trSvc = document.createElement('tr');
          trSvc.innerHTML = `<td>${itm.name}</td><td style="text-align:center">${qty}</td><td style="text-align:right">$${price.toFixed(2)}</td><td style="text-align:right">$${total.toFixed(2)}</td>`;
          itemsTbody.appendChild(trSvc);
        }
      }

      const taxRate = Number(invObj.tax_rate) || 0;
      const discountRate = Number(invObj.discount) || 0;
      const tax = subtotal * (taxRate / 100);
      const discount = subtotal * (discountRate / 100);
      const grand = subtotal + tax - discount;

      subEl.textContent = subtotal.toFixed(2);
      taxEl.textContent = tax.toFixed(2);
      discEl.textContent = discount.toFixed(2);
      grandEl.textContent = grand.toFixed(2);

      // Footer shop name for print
  const footerEl = document.getElementById('footerShopName');
  if (footerEl) footerEl.textContent = displayName || '';
    }

    if (inv) {
      // If we found the invoice in local cache, still prefer authoritative
      // shop info: try getShopData() and Supabase `shops` table before using xm_shops.
      let src = 'xm_data';
      if (data && data.settings && data.settings.shop) src = 'data.settings';
      else if (localStorage.getItem('xm_shops')) src = 'xm_shops';

      try {
        const supabase = await getSupabaseClient();
        // Determine candidate shopId from invoice, data.settings, session, or xm_shops
        let candidateShopId = null;
        try {
          if (inv && inv.shop_id) candidateShopId = inv.shop_id;
          if (!candidateShopId && data && data.settings && data.settings.shop) {
            const s0 = Array.isArray(data.settings.shop) ? data.settings.shop[0] : data.settings.shop;
            if (s0 && (s0.id || s0.shop_id)) candidateShopId = s0.id || s0.shop_id;
          }
          if (!candidateShopId) {
            const sess = JSON.parse(localStorage.getItem('xm_session') || 'null') || {};
            candidateShopId = sess.shop_id || sess.shopId || candidateShopId;
          }
          if (!candidateShopId) {
            const xmSh = JSON.parse(localStorage.getItem('xm_shops') || 'null');
            if (Array.isArray(xmSh) && xmSh.length) candidateShopId = xmSh[0].id || xmSh[0].shop_id || null;
          }
        } catch (e) { /* ignore */ }
        let authoritative = null;
        let authoritativeSrc = null;

        // 1) Try the storage helper (may fetch data.settings from server or LS)
        try {
          if (typeof getShopData === 'function') {
            const shopBlob = await getShopData(candidateShopId);
            if (shopBlob && shopBlob.settings && shopBlob.settings.shop) {
              const s = Array.isArray(shopBlob.settings.shop) ? shopBlob.settings.shop[0] : shopBlob.settings.shop;
              if (s && s.name && !['GR Automotive', 'Demo Shop'].includes(s.name.trim())) {
                authoritative = s;
                authoritativeSrc = 'data.settings';
              }
            }
          }
        } catch (e) { /* ignore */ }

        // 2) If not found, ask Supabase shops table directly
        if (!authoritative && supabase && candidateShopId) {
          try {
            const { data: sres, error: sErr } = await supabase.from('shops').select('*').eq('id', candidateShopId).limit(1).single();
            if (!sErr && sres && sres.name && !['GR Automotive', 'Demo Shop'].includes((sres.name||'').trim())) {
              authoritative = sres;
              authoritativeSrc = 'shops_table';
            }
          } catch (e) { /* ignore */ }
        }

        // If we found authoritative shop info, merge it into local data for rendering
        if (authoritative) {
          const allData = Object.assign({}, data || {});
          allData.settings = allData.settings || {};
          allData.settings.shop = authoritative;
          renderInvoice(inv, allData, authoritativeSrc);
          return;
        }
        // 3) If still not authoritative, and we have a candidateShopId, fetch exactly like settings page:
        //    - shops row from `shops`
        //    - settings from `data` table
        try {
          if (!authoritative && supabase && candidateShopId) {
            const { data: shopRow, error: shopErr } = await supabase.from('shops').select('*').eq('id', candidateShopId).single();
            let settingsRow = null;
            try {
              const { data: drow, error: dErr } = await supabase.from('data').select('settings').eq('shop_id', candidateShopId).single();
              if (!dErr && drow) settingsRow = drow.settings || null;
            } catch(e) {}

            // Debug show what we fetched
            // ...existing code...

            if (shopRow && shopRow.name && !['GR Automotive', 'Demo Shop'].includes((shopRow.name||'').trim())) {
              const allData = Object.assign({}, data || {});
              allData.settings = settingsRow || {};
              allData.settings.shop = shopRow;
              renderInvoice(inv, allData, 'shops_table');
              return;
            }
          }
        } catch (e) { /* ignore */ }
      } catch (e) {
        // ignore any failure and fall back to local caches below
        console.warn('Invoice local path: authoritative shop lookup failed', e);
      }

      // No authoritative info found ‚Äî render with local cache source
      renderInvoice(inv, data, src);
      return;
    }

    // If not in local xm_data, try xm_invoices or xm_shops
    const alt = JSON.parse(localStorage.getItem('xm_invoices') || 'null');
    if (!inv && alt && Array.isArray(alt)) {
      inv = alt.find(i => String(i.id) === id || String(i.number) === id);
      if (inv) { renderInvoice(inv, data); return; }
    }

    // Try to fetch the invoices from the Supabase-backed `invoices` table (via shared helper)
    try {
      const supabase = await getSupabaseClient();

      // Helper: fetch shop info robustly (use storage helper first, then shops table)
      async function fetchShopInfo(shopId) {
        try {
          if (typeof getShopData === 'function') {
            const shopBlob = await getShopData(shopId);
            if (shopBlob && shopBlob.settings && shopBlob.settings.shop) {
              const s = Array.isArray(shopBlob.settings.shop) ? shopBlob.settings.shop[0] : shopBlob.settings.shop;
              if (s && s.name) return s;
            }
          }
        } catch (e) { /* ignore */ }

        try {
          if (supabase && typeof supabase.from === 'function') {
            const { data: sres, error: sErr } = await supabase.from('shops').select('*').eq('id', shopId).limit(1).single();
            if (!sErr && sres) return sres;
          }
        } catch (e) { /* ignore */ }

        return null;
      }

      if (supabase) {
        // Try invoices table first
        const { data: rows, error } = await supabase.from('invoices').select('*').or(`id.eq.${id},number.eq.${id}`).limit(1);
        if (!error && rows && rows.length) {
          inv = rows[0];

          // Attempt to fetch shop info if not present in local data
          let allData = data;
          let shopSrc = undefined;
          if ((!allData.settings || !allData.settings.shop) && inv && inv.shop_id) {
            const fetched = await fetchShopInfo(inv.shop_id);
            if (fetched) {
              allData = Object.assign({}, allData);
              allData.settings = allData.settings || {};
              allData.settings.shop = fetched.shop;
              shopSrc = fetched.source;
            }
          }

          renderInvoice(inv, allData, shopSrc);
          return;
        }
      }
    } catch (e) { console.warn('Supabase invoice fetch failed', e); }

  } catch (e) { console.error('Failed to render invoice', e); }

  // Override print handler: wait for print logo loader (or images) to load before calling print,
  // so the print preview includes the correct shop logo.
  window.printInvoice = async function(timeout = 1500){
    try{
  const ids = ['printFooterLogoLoader','printFooterLogo'];
      for(const id of ids){
        const el = document.getElementById(id);
        if(!el || !el.src) continue;
        if(el.complete && el.naturalWidth && el.naturalWidth>0) break;
        await new Promise(res => {
          let done = false;
          const ondone = ()=>{ if(done) return; done=true; cleanup(); res(); };
          const onerr = ()=>{ if(done) return; done=true; cleanup(); res(); };
          function cleanup(){ el.removeEventListener('load', ondone); el.removeEventListener('error', onerr); }
          el.addEventListener('load', ondone);
          el.addEventListener('error', onerr);
          setTimeout(()=>{ if(done) return; done=true; cleanup(); res(); }, timeout);
        });
        break;
      }
    }catch(e){}
    try{ window.print(); }catch(e){ window.print(); }
  };

  // ============================================
  // SEND INVOICE FUNCTIONALITY
  // ============================================
  
  // Store current invoice data for sending
  window.currentInvoiceForSend = invObj;
  window.currentShopId = invObj?.shop_id || null;

  console.log('[Invoice] renderInvoice called with invoice:', invObj?.id, invObj?.number);

  // Wire up send invoice button
  const sendBtn = document.getElementById('sendInvoiceBtn');
  console.log('[Invoice] sendBtn element:', sendBtn);
  console.log('[Invoice] invObj exists?', !!invObj);
  
  if (sendBtn && invObj) {
    console.log('[Invoice] Wiring up send button for invoice:', invObj.id);
    sendBtn.onclick = () => {
      console.log('[Invoice] Send button clicked!');
      showSendInvoiceModal(invObj);
    };
  } else {
    console.warn('[Invoice] Could not wire up send button - sendBtn:', !!sendBtn, 'invObj:', !!invObj);
  }

})();
</script>

<script>
  // Send Invoice Modal Functions
  window.closeSendInvoiceModal = function() {
    console.log('[SendInvoice] closeSendInvoiceModal called');
    const modal = document.getElementById('sendInvoiceModal');
    if (modal) modal.classList.add('hidden');
  };

  // Add click listener to button as fallback
  document.addEventListener('DOMContentLoaded', () => {
    const sendBtn = document.getElementById('sendInvoiceBtn');
    if (sendBtn) {
      console.log('[SendInvoice] Fallback: Adding direct click listener to sendInvoiceBtn');
      sendBtn.addEventListener('click', async (e) => {
        console.log('[SendInvoice] Button clicked via event listener!', window.currentInvoiceForSend);
        
        // If we have the invoice stored, use it
        if (window.currentInvoiceForSend) {
          showSendInvoiceModal(window.currentInvoiceForSend);
          return;
        }
        
        // Otherwise, try to get it from the page data
        console.log('[SendInvoice] Trying to find invoice from page elements...');
        const invNo = document.getElementById('invNo')?.textContent;
        const invCustomer = document.getElementById('invCustomer')?.textContent;
        const urlParams = new URLSearchParams(window.location.search);
        const invoiceId = urlParams.get('id');
        
        console.log('[SendInvoice] Invoice ID from URL:', invoiceId, 'invNo:', invNo);
        
        if (invoiceId) {
          // Try to fetch the invoice from Supabase to get full data
          try {
            // Get shop ID from session (same way as invoices.js does)
            let shopId = null;
            try {
              const session = JSON.parse(localStorage.getItem('xm_session') || '{}');
              shopId = session.shopId || null;
            } catch (e) { }
            
            console.log('[SendInvoice] Fetching invoice data - shopId:', shopId, 'invoiceId:', invoiceId);
            
            const supabase = window._supabaseClient;
            if (!supabase) {
              console.warn('[SendInvoice] Supabase client not available');
              throw new Error('Supabase client not available');
            }
            
            if (!shopId) {
              console.warn('[SendInvoice] Shop ID not found');
              throw new Error('Shop ID not found. Please reload the page.');
            }
            
            // Try to find the invoice in the data table
            const { data: shopData, error: dataError } = await supabase
              .from('data')
              .select('invoices, appointments, jobs')
              .eq('shop_id', shopId);
            
            if (dataError) throw dataError;
            
            if (!shopData || shopData.length === 0) {
              console.warn('[SendInvoice] No data found for shop:', shopId);
              throw new Error('No shop data found');
            }
            
            const data = shopData[0]; // Get the first (and should be only) row
            
            let invoice = null;
            let appointmentId = null;
            let jobId = null;
            
            // Find invoice in invoices array
            if (data?.invoices) {
              invoice = data.invoices.find(inv => inv.id === invoiceId);
              if (invoice) {
                appointmentId = invoice.appointment_id;
                jobId = invoice.job_id;
              }
            }
            
            console.log('[SendInvoice] Found invoice:', invoice?.id, 'appointment:', appointmentId, 'job:', jobId);
            
            if (!invoice) {
              console.warn('[SendInvoice] Invoice not found in Supabase');
              throw new Error('Invoice not found');
            }
            
            // Fetch customer data - prioritize appointments table (source of truth)
            let customerEmail = '';
            let customerPhone = '';
            let customerName = '';
            
            // Build customer name from invoice
            if (invoice.customer_first || invoice.customer_last) {
              customerName = `${invoice.customer_first || ''} ${invoice.customer_last || ''}`.trim();
            }
            
            // PRIORITY 1: Fetch from appointments table (PRIMARY source of truth)
            // The appointments table stores customer contact info directly on each appointment
            if (appointmentId) {
              console.log('[SendInvoice] Fetching FRESH contact from appointments table:', appointmentId);
              const { data: appt, error: apptError } = await supabase
                .from('appointments')
                .select('email, phone, customer_first, customer_last')
                .eq('id', appointmentId)
                .single();
              
              if (!apptError && appt) {
                customerEmail = appt.email || '';
                customerPhone = appt.phone || '';
                if (!customerName && (appt.customer_first || appt.customer_last)) {
                  customerName = `${appt.customer_first || ''} ${appt.customer_last || ''}`.trim();
                }
                console.log('[SendInvoice] Got contact from appointments table:', { customerEmail, customerPhone, customerName });
              } else if (apptError) {
                console.warn('[SendInvoice] Error fetching from appointments table:', apptError);
              }
            }
            
            // PRIORITY 2: Fallback to jobs table if appointment lookup failed or incomplete
            if (jobId && (!customerEmail || !customerPhone)) {
              console.log('[SendInvoice] Fallback: Fetching from jobs table:', jobId);
              const { data: job, error: jobError } = await supabase
                .from('jobs')
                .select('email, phone, customer_first, customer_last')
                .eq('id', jobId)
                .single();
              
              if (!jobError && job) {
                if (!customerEmail && job.email) customerEmail = job.email;
                if (!customerPhone && job.phone) customerPhone = job.phone;
                if (!customerName && (job.customer_first || job.customer_last)) {
                  customerName = `${job.customer_first || ''} ${job.customer_last || ''}`.trim();
                }
                console.log('[SendInvoice] Got contact from jobs table:', { customerEmail, customerPhone });
              }
            }
            
            // PRIORITY 3: Last resort fallback to customers table (only for saved repeat customers)
            // Note: customers table is ONLY populated when user explicitly clicks "Save Customer"
            if (invoice.customer_id && (!customerEmail || !customerPhone)) {
              console.log('[SendInvoice] Last resort: Fetching from customers table:', invoice.customer_id);
              const { data: customer, error: custError } = await supabase
                .from('customers')
                .select('email, phone, customer_first, customer_last')
                .eq('id', invoice.customer_id)
                .single();
              
              if (!custError && customer) {
                if (!customerEmail) customerEmail = customer.email || '';
                if (!customerPhone) customerPhone = customer.phone || '';
                if (!customerName && (customer.customer_first || customer.customer_last)) {
                  customerName = `${customer.customer_first || ''} ${customer.customer_last || ''}`.trim();
                }
                console.log('[SendInvoice] Got contact from customers table:', { customerEmail, customerPhone });
              }
            }
            
            const inv = {
              id: invoice.id,
              number: invoice.number || invoiceId,
              customer_id: invoice.customer_id,
              customer_first: customerName?.split(' ')[0] || '',
              customer_last: customerName?.split(' ').slice(1).join(' ') || '',
              shop_id: shopId,
              appointment_id: invoice.appointment_id || null,
              job_id: invoice.job_id || null,
              items: invoice.items || [],
              tax_rate: invoice.tax_rate || 0,
              discount: invoice.discount || 0,
              status: invoice.status || 'unpaid'
            };
            
            console.log('[SendInvoice] Built complete invoice object:', inv);
            
            // Store the email and phone for the modal
            window.currentInvoiceForSend = inv;
            window.currentInvoiceEmail = customerEmail;
            window.currentInvoicePhone = customerPhone;
            window.currentInvoiceCustomerName = customerName;
            
            showSendInvoiceModal(inv);
          } catch (error) {
            console.error('[SendInvoice] Error fetching invoice data:', error);
            alert('Error loading customer info. Please try again.');
          }
        }
      });
    }
  });

  async function showSendInvoiceModal(inv) {
    console.log('[SendInvoice] showSendInvoiceModal called with invoice:', inv?.id);
    const modal = document.getElementById('sendInvoiceModal');
    console.log('[SendInvoice] modal element:', modal);
    if (!modal || !inv) {
      console.warn('[SendInvoice] Modal or invoice missing - modal:', !!modal, 'inv:', !!inv);
      return;
    }

    // ALWAYS fetch fresh customer data - prioritize appointments table (source of truth)
    let customerEmail = '';
    let customerPhone = '';
    let customerName = '';

    // Build customer name from invoice if available
    if (inv.customer_first || inv.customer_last) {
      customerName = `${inv.customer_first || ''} ${inv.customer_last || ''}`.trim();
    }

    const supabase = window._supabaseClient;
    
    // PRIORITY 1: Fetch from appointments table (PRIMARY source of truth for contact info)
    // The appointments table stores customer contact info directly on each appointment
    if (supabase && inv.appointment_id) {
      try {
        console.log('[SendInvoice] Fetching FRESH contact from appointments table for appointment_id:', inv.appointment_id);
        const { data: appt, error } = await supabase
          .from('appointments')
          .select('email, phone, customer_first, customer_last')
          .eq('id', inv.appointment_id)
          .single();
        
        if (!error && appt) {
          customerEmail = appt.email || '';
          customerPhone = appt.phone || '';
          if (!customerName && (appt.customer_first || appt.customer_last)) {
            customerName = `${appt.customer_first || ''} ${appt.customer_last || ''}`.trim();
          }
          console.log('[SendInvoice] Got contact from appointments table - email:', customerEmail, 'phone:', customerPhone, 'name:', customerName);
        } else if (error) {
          console.warn('[SendInvoice] Error fetching appointment:', error);
        }
      } catch (e) {
        console.warn('[SendInvoice] Could not fetch from appointments table:', e);
      }
    }
    
    // PRIORITY 2: Fallback to jobs table if appointment lookup failed or incomplete
    if (supabase && inv.job_id && (!customerEmail || !customerPhone)) {
      try {
        console.log('[SendInvoice] Fallback: Fetching from jobs table for job_id:', inv.job_id);
        const { data: job, error } = await supabase
          .from('jobs')
          .select('email, phone, customer_first, customer_last')
          .eq('id', inv.job_id)
          .single();
        
        if (!error && job) {
          if (!customerEmail && job.email) customerEmail = job.email;
          if (!customerPhone && job.phone) customerPhone = job.phone;
          if (!customerName && (job.customer_first || job.customer_last)) {
            customerName = `${job.customer_first || ''} ${job.customer_last || ''}`.trim();
          }
          console.log('[SendInvoice] Got contact from jobs table - email:', customerEmail, 'phone:', customerPhone);
        }
      } catch (e) {
        console.warn('[SendInvoice] Could not fetch from jobs table:', e);
      }
    }
    
    // PRIORITY 3: Last resort fallback to customers table (only for saved repeat customers)
    // Note: customers table is ONLY populated when user explicitly clicks "Save Customer"
    if (supabase && inv.customer_id && (!customerEmail || !customerPhone)) {
      try {
        console.log('[SendInvoice] Last resort: Fetching from customers table for customer_id:', inv.customer_id);
        const { data: customer, error } = await supabase
          .from('customers')
          .select('email, phone, customer_first, customer_last')
          .eq('id', inv.customer_id)
          .single();
        
        if (!error && customer) {
          if (!customerEmail) customerEmail = customer.email || '';
          if (!customerPhone) customerPhone = customer.phone || '';
          if (!customerName && (customer.customer_first || customer.customer_last)) {
            customerName = `${customer.customer_first || ''} ${customer.customer_last || ''}`.trim();
          }
          console.log('[SendInvoice] Got contact from customers table - email:', customerEmail, 'phone:', customerPhone);
        }
      } catch (e) {
        console.warn('[SendInvoice] Could not fetch from customers table:', e);
      }
    }

    // Update the global cache with fresh data
    window.currentInvoiceEmail = customerEmail;
    window.currentInvoicePhone = customerPhone;
    window.currentInvoiceCustomerName = customerName;

    console.log('[SendInvoice] Final customer contact info - email:', customerEmail, 'phone:', customerPhone, 'name:', customerName);

    // Update UI elements
    const emailCheckbox = document.getElementById('sendEmailCheckbox');
    const smsCheckbox = document.getElementById('sendSmsCheckbox');
    const emailAddressEl = document.getElementById('sendEmailAddress');
    const smsPhoneEl = document.getElementById('sendSmsPhone');
    const noContactEl = document.getElementById('sendInvoiceNoContact');
    const statusEl = document.getElementById('sendInvoiceStatus');
    const sendBtnModal = document.getElementById('sendInvBtn');

    // Reset status
    if (statusEl) {
      statusEl.style.display = 'none';
      statusEl.innerHTML = '';
    }

    // Email option
    if (customerEmail) {
      if (emailCheckbox) emailCheckbox.disabled = false;
      if (emailCheckbox) emailCheckbox.checked = true;
      if (emailAddressEl) emailAddressEl.textContent = customerEmail;
    } else {
      if (emailCheckbox) emailCheckbox.disabled = true;
      if (emailCheckbox) emailCheckbox.checked = false;
      if (emailAddressEl) emailAddressEl.textContent = 'No email on file';
    }

    // SMS option
    if (customerPhone) {
      if (smsCheckbox) smsCheckbox.disabled = false;
      if (smsCheckbox) smsCheckbox.checked = true;
      if (smsPhoneEl) smsPhoneEl.textContent = customerPhone;
    } else {
      if (smsCheckbox) smsCheckbox.disabled = true;
      if (smsCheckbox) smsCheckbox.checked = false;
      if (smsPhoneEl) smsPhoneEl.textContent = 'No phone on file';
    }

    // Show warning if no contact info
    if (!customerEmail && !customerPhone) {
      if (noContactEl) noContactEl.style.display = 'block';
      if (sendBtnModal) sendBtnModal.disabled = true;
    } else {
      if (noContactEl) noContactEl.style.display = 'none';
      if (sendBtnModal) sendBtnModal.disabled = false;
    }

    // Check if Google Business is configured for the shop AND invoice is paid
    let hasGoogleBusiness = false;
    const isPaidInvoice = inv.status === 'paid';
    if (supabase && inv.shop_id && isPaidInvoice) {
      try {
        const { data: shopData } = await supabase
          .from('shops')
          .select('google_business_url, google_business_name')
          .eq('id', inv.shop_id)
          .single();
        
      } catch (e) {
        console.warn('[SendInvoice] Could not check Google Business:', e);
      }
    }

    // Store data on modal for sending
    modal.dataset.invoiceId = inv.id;
    modal.dataset.shopId = inv.shop_id;
    modal.dataset.email = customerEmail;
    modal.dataset.phone = customerPhone;
    modal.dataset.customerName = customerName;

    console.log('[SendInvoice] Contact info - email:', customerEmail, 'phone:', customerPhone);

    // Set invoice number in modal
    const invNumberEl = document.getElementById('sendInvNumber');
    if (invNumberEl) {
      invNumberEl.textContent = inv.number || inv.id.slice(0, 8);
    }

    // Wire up send button
    if (sendBtnModal) {
      sendBtnModal.onclick = () => sendInvoiceFromPage();
    }

    // Show modal
    console.log('[SendInvoice] Showing modal');
    modal.classList.remove('hidden');
    console.log('[SendInvoice] Modal should now be visible');
  }

  async function sendInvoiceFromPage() {
    console.log('[SendInvoice] sendInvoiceFromPage called');
    const modal = document.getElementById('sendInvoiceModal');
    const sendBtnModal = document.getElementById('sendInvBtn');
    const statusEl = document.getElementById('sendInvoiceStatus');
    const emailCheckbox = document.getElementById('sendEmailCheckbox');
    const smsCheckbox = document.getElementById('sendSmsCheckbox');

    const sendEmail = emailCheckbox?.checked && !emailCheckbox?.disabled;
    const sendSms = smsCheckbox?.checked && !smsCheckbox?.disabled;

    console.log('[SendInvoice] sendEmail:', sendEmail, 'sendSms:', sendSms);

    if (!sendEmail && !sendSms) {
      console.warn('[SendInvoice] No delivery method selected');
      if (statusEl) {
        statusEl.style.display = 'block';
        statusEl.style.background = '#fef3c7';
        statusEl.style.color = '#92400e';
        statusEl.innerHTML = 'Please select at least one delivery method.';
      }
      return;
    }

    // Show loading state
    if (sendBtnModal) {
      sendBtnModal.disabled = true;
      sendBtnModal.textContent = 'Sending...';
    }
    if (statusEl) {
      statusEl.style.display = 'block';
      statusEl.style.background = '#e0f2fe';
      statusEl.style.color = '#0369a1';
      statusEl.innerHTML = '‚è≥ Sending invoice...';
    }

    try {
      // Always use Vercel server for send-invoice (has Twilio/Resend credentials)
      const API_URL = 'https://xpose-stripe-server.vercel.app';
      
      console.log('[SendInvoice] Sending to API:', API_URL, {
        invoiceId: modal.dataset.invoiceId,
        shopId: modal.dataset.shopId,
        sendEmail,
        sendSms,
        customerEmail: modal.dataset.email,
        customerPhone: modal.dataset.phone
      });

      const response = await fetch(`${API_URL}/api/send-invoice`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          invoiceId: modal.dataset.invoiceId,
          shopId: modal.dataset.shopId,
          sendEmail,
          sendSms,
          customerEmail: modal.dataset.email || null,
          customerPhone: modal.dataset.phone || null,
          customerName: modal.dataset.customerName || 'Customer'
        })
      });

      console.log('[SendInvoice] API response status:', response.status);
      const result = await response.json();
      console.log('[SendInvoice] API result:', result);

      if (result.success) {
        if (statusEl) {
          statusEl.style.background = '#d1fae5';
          statusEl.style.color = '#065f46';
          let msg = '‚úÖ Invoice sent successfully!';
          if (result.results?.email?.success && result.results?.sms?.success) {
            msg = '‚úÖ Invoice sent via email and SMS!';
          } else if (result.results?.email?.success) {
            msg = '‚úÖ Invoice sent via email!';
          } else if (result.results?.sms?.success) {
            msg = '‚úÖ Invoice sent via SMS!';
          }
          
          statusEl.innerHTML = msg;
        }
        // Auto-close after success
        setTimeout(() => {
          closeSendInvoiceModal();
        }, 2500);
      } else {
        // Partial success or failure
        if (statusEl) {
          statusEl.style.background = '#fef3c7';
          statusEl.style.color = '#92400e';
          let msg = '‚ö†Ô∏è ';
          if (result.results?.email && !result.results.email.success) {
            msg += `Email failed: ${result.results.email.error}. `;
          }
          if (result.results?.sms && !result.results.sms.success) {
            msg += `SMS failed: ${result.results.sms.error}. `;
          }
          statusEl.innerHTML = msg || 'Failed to send invoice.';
        }
      }
    } catch (error) {
      console.error('[SendInvoice] Error:', error);
      if (statusEl) {
        statusEl.style.background = '#fee2e2';
        statusEl.style.color = '#991b1b';
        statusEl.innerHTML = `‚ùå Error: ${error.message || 'Failed to send invoice'}`;
      }
    } finally {
      if (sendBtnModal) {
        sendBtnModal.disabled = false;
        sendBtnModal.textContent = 'Send Invoice';
      }
    }
  }
</script>
</body></html>
